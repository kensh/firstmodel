load ./compile.maude


mod VIRTUAL is
 pr CONNECTIONS .
 pr MACHINES .
 sort Virtual .
 
 op v : Nat -> Virtual [ctor] .
 op con__ : Machine Machine -> Pair{Machine, Machine} .
 
endm


mod REAL is
 pr CONNECTIONS .
 pr MACHINES .
 sort Real . 
 
 op r : Bag{Machine} Bag{Connection} -> Real [ctor] .
 op add : Machine Real -> Real .
 op con : Machine Machine Real -> Real .

 vars X Y : Machine .
 var R : Real .
 var M : Bag{Machine} .
 var C : Bag{Connection} .

 eq add(X, r(M,C)) = r(X M, C) .  
 eq con(X,Y, r(M,C)) = r(M, [X,Y] C) .

endm


mod CHEF is
 pr VIRTUAL .
 pr REAL .
 pr NAT .
 sort Chef .
 sort State .

 subsorts Chef < Real Virtual . 

 op initial : -> State [ctor] .
 op terminal : -> State [ctor] .
 op alive : -> State [ctor] .

 op chef : State Virtual Real -> Chef [ctor] .
 op test : Nat -> Nat .

 var X : Nat .
 eq test(X) = 10 .
 
****rl [dq2] : (pc[I]: ds) (queue: Q) (tmp[I]: R) => (pc[I]: rs) (queue: R) (tmp[I]: R) . 

***  rl [rule1] : (pc[I]: ds) (queue: Q) (tmp[I]: R) => (pc[I]: rs) (queue: R) (tmp[I]: R) .

 var S : State .
 var V : Virtual .
 var R : Real .
 var total : Nat .


 rl [alive] : chef(initial, V, R) =>  chef(alive, V, R) .
 rl [add_real] : chef(alive, V, r(ap(1) db(1),[ap(1),db(1)]) ) => chef(alive, V, add(ap(2), r(ap(1) db(1),[ap(1),db(1)])) ) .


endm

select CHEF .

search [1] in CHEF : chef(initial, v(0) , r(ap(1) db(1),[ap(1),db(1)]) ) =>+  chef(alive, v(0) , r(ap(1) ap(2) db(1),[ap(1),db(1)]) ) .
*** show path 1 .


*** rewrite [3] in CHEF : chef (initial, v(123), r(ap(1) db(1),[ap(1),db(1)]) .



***(
red c(initial, v(111), r(db(1) ap(1), mt) ).

red [db(1),ap(3)] .
red add(db(1) , r(ap(1) ap(2), [ap(1),ap(2)])) .
red con(db(1),ap(1), r(db(1) ap(1), mt)) .

select CHEF .
red test(19) .
)***

quit
